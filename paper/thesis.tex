\documentclass[12pt,twoside,openright]{report}

\usepackage[backend=biber,style=ieee]{biblatex}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz}
\usepackage{mathtools,amssymb,amsthm,mathpartir,fitch}
\usepackage[llbracket,rrbracket]{stmaryrd}
\usepackage{listings}
\usepackage[top=3cm,bottom=3cm,inner=3cm,outer=3cm]{geometry}
\usepackage{parskip,titlesec,fancyhdr,microtype}

\bibliography{sources.bib}

\numberwithin{equation}{chapter}
\numberwithin{figure}{chapter}
\numberwithin{table}{chapter}

\titleformat
    {\chapter}[display]
    {\Huge\bfseries\filcenter}
    {\vspace{-4.2ex}\fontsize{50pt}{1em}\normalfont\thechapter}{1ex}{}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter. #1}{}}
\fancyhf{}
\fancyhead[LE,RO]{\nouppercase{\leftmark}}
\fancyfoot[LE,RO]{\thepage}
\setlength{\headheight}{15pt}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}\newtheorem{definition}{Definition}

\mprset{sep=1.5em} % Decrease spacing between \inferrule premises

\newcommand{\tikznode}[2]{\tikz[remember picture,baseline=(#1.base),inner sep=0pt] \node (#1) {#2};}

\newcommand{\lock}{\text{\tikz[baseline]{
      \fill[rounded corners=.1ex] (-.75ex,0) rectangle (.75ex,1ex);
      \draw[line width=.3ex] (-.4ex,.5ex) -- ++(0,.75ex) arc (180:0:.4ex) -- ++(0,-.75ex);
}}}

\DeclareMathOperator\Rpl{Rpl}
\DeclareMathOperator\unbox{unbox}

\newcommand{\oneLineTitle}{A Parametric Fitch-Style Modal Lambda Calculus}
\newcommand{\multiLineTitle}[1]{A Parametric Fitch-Style \\[#1] Modal Lambda Calculus}

\begin{document}
\pagenumbering{roman}

\begin{titlepage}
\newgeometry{top=5cm,bottom=1cm,left=2.25cm,right=2.25cm}
\AddToHookNext{shipout/background}{\put (-4pt,-\paperheight)
  {\includegraphics[width=\paperwidth,height=\paperheight]{frontpage_gu_eng}}}

\mbox{}
\vfill
\renewcommand{\familydefault}{\sfdefault}\normalfont

\textbf{\Huge \multiLineTitle{0.2cm}} \setlength{\parskip}{0.5cm}

Master's thesis in Computer science and engineering \setlength{\parskip}{1cm}

{\Large Axel Forsman} \setlength{\parskip}{2.9cm}

Department of Computer Science and Engineering \\
\textsc{Chalmers University of Technology} \\
\textsc{University of Gothenburg} \\
Gothenburg, Sweden \the\year
\end{titlepage}

\newpage
\renewcommand{\familydefault}{\rmdefault}\normalfont
\restoregeometry
\thispagestyle{empty}
\mbox{}

% TITLE PAGE
\newpage
\thispagestyle{empty}
\begin{center}
	\textsc{\large Master's thesis \the\year} \\[4cm]
	\textbf{\Large \multiLineTitle{0.2cm}} \\[2cm]
    %% {\large \oneLineSubtitle} \\[1cm]
	{\large Axel Forsman}

	\vfill
	%% Logotype on title page
    \begin{center}
	\includegraphics[width=0.25\pagewidth]{ChGULogo}
    \end{center}
	\vspace{5mm}

	Department of Computer Science and Engineering \\
	%% \emph{Division of Division name} \\
	\textsc{Chalmers University of Technology} \\
	\textsc{University of Gothenburg} \\
	Gothenburg, Sweden \the\year
\end{center}

% IMPRINT PAGE (BACK OF TITLE PAGE)
{
\newpage
\thispagestyle{plain}
\setlength{\parskip}{1cm}
\vspace*{4.5cm}
\oneLineTitle \\
%% \oneLineSubtitle \\
Axel Forsman

\copyright~Axel Forsman, \the\year.

Supervisor: Nachiappan Valliappan, Department of Computer Science and Engineering \\
Examiner: Andreas Abel, Department of Computer Science and Engineering

Master's Thesis \the\year \\
Department of Computer Science and Engineering \\
Chalmers University of Technology and University of Gothenburg \\
SE-412 96 Gothenburg \\
Telephone +46 31 772 1000

\vfill
% Caption for cover page figure if used, possibly with reference to further information in the report
%% Cover: Description of the picture on the cover page (if applicable)

Typeset in \LaTeX \\
%% Printed by [Name of printing company] \\
Gothenburg, Sweden \the\year
}

\newpage
\thispagestyle{plain}
\oneLineTitle \\
%% \oneLineSubtitle \\
Axel Forsman \\
Department of Computer Science and Engineering \\
Chalmers University of Technology and University of Gothenburg

\section*{Abstract}
The \emph{necessity modality}, denoted by \Box, where the focus lies,
has been applied to model staged computations,
compartmental purity in functional languages,
and more.
So called Fitch-style modal deduction,
where modalities are eliminated by opening a subproof,
and introduced by shutting one,
has been adapted for lambda calculi.
Different modal logics may be encoded via different open and shut rules.
Prior work \cite{valliappan22} has given normalization proofs
for four Fitch-style formulations of lambda calculi with different modalities,
which required repeating the proofs for each individual calculus.
A parametric Fitch-style modal lambda calculus generalizing the variants is presented,
in order to avoid the repetition and ease further extensions.

\vfill
% KEYWORDS (MAXIMUM 10 WORDS)
Keywords: Necessity, modality, parametric, Fitch, modal, lambda calculus, normalization.

\newpage
\thispagestyle{empty}
\mbox{}

\newpage
\thispagestyle{plain}
\section*{Acknowledgments}

I wish to thank my supervisor for their guidance and patience,
and my family for their support.

\vspace{1.5cm}\hfill
Axel Forsman, Gothenburg, \today

\newpage
\thispagestyle{empty}
\mbox{}

\newpage
\tableofcontents

\cleardoublepage
\phantomsection\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures

\cleardoublepage
\setcounter{page}{1}
\pagenumbering{arabic}

\chapter{Introduction}

In this thesis we consider the so called \emph{necessity modality},
and go on to give a parametric modal lambda calculus in the Fitch-style
which integrates the necessity modality.

To see the need for modalities in programming languages,
it helps to start with understanding the usefulness of type systems.
Broadly speaking,
type systems are a means of classifying expressions by the values they compute,
in order to prove the absence of unsatisfactory program behaviors \cite{pierce02}.
If two expressions are known to produce strings of characters,
then trying to add them as if they were instead numbers
can be statically rejected - without the need to execute the program beforehand.
It is clear that a type system cannot be a one-to-one correspondence
with the untyped language;
that would not make proving anything easier.
Designing a type system will therefore always involve trade-offs:
Make it more liberal in the amount of programs that are admissible,
and reasoning and proving of meta-theoretic properties become harder;
do the opposite and there will be more correct programs
that are impossible to type check.
Thus a plethora of type system concepts have been invented,
e.g.\@ union types, algebraic data types, type classes, and polymorphism, to name a few.

Modalities in type theory are one such concept,
where they act as unary type constructors
that impose some properties and restrictions,
i.e.\@ given some type they construct a new type.
The necessity modality, denoted by `\Box',
also mandates the rule of necessitation:
It is possible to obtain a value of type $\Box A$
if a value of type $A$ can be derived without any assumptions.
It has found use in modeling a number of different things.

In the context of type systems, what is meant by \emph{modeling} some concept
is constraining a type in such a way that all values of that type
have the set of properties that define the concept.
One example of this is the use of modalities for \emph{staged computations} \cite{davies01},
which is further elaborated upon in \autoref{sec:staged-computation}.
A staged computation is one that proceeds in a sequence of stages,
with the earlier stages generating code for each consecutive stage.
By introducing modalities to the type system,
we are able to write functions of the type
$$ A \to \Box (B \to C) $$
that given a value $a$ of type $A$ will at run-time take the resulting function from $B$ to $C$,
and specialize it depending on the concrete value of $a$.
For example, were we to write multiplication as a function
$\mathbb N \to \Box (\mathbb N \to \mathbb N)$,
then applying it to the number zero could yield simply
the constant function that always returns zero.
Here, the `\Box' modality is used to model uninterpreted code,
and its properties ensure all computation concerned with the argument $a$
is carried out while generating the code for the next stage,
else the value $a$ needs to be embedded in the code as a literal.
This allows a compiler to safely apply the transformation.

There have been different approaches to integrating the necessity modality into lambda calculus,
where we introduce new operators, $\operatorname{box}$ and $\operatorname{unbox}$,
to work with types involving the \Box{} type constructor.
Fitch-style is one of them,
inspired by the proof notation for modal logic due to Fitch \cite{borghuis94}.
It has been shown that the resulting calculi have great computational properties,
qualifying them for adaptation into real-world programming languages.
Prior work by \textcite{valliappan22} gave formulations
of four different Fitch-style modal lambda calculi,
each corresponding to different modal logics.
They also implemented normalization for these calculi,
an important meta-theoretic property.
Two of these formulations were proved correct
by mechanizing them in the proof assistant Agda \cite{norell07}.

However, there was a lot duplication between the two mechanizations
which totaled over five thousand lines of Agda code.
This includes the formulation of the simply typed lambda calculus foundation
that was present in both.
Furthermore, this repetition would only continue to increase
with each additional modal lambda calculus mechanized.
This in spite of the fact that for all four calculi in question
only the rules surrounding the $\operatorname{unbox}$ operator vary,
while the $\operatorname{box}$ operator and everything else stay the same.

The contributions of this thesis are therefore:
\begin{itemize}
\item The design of a modal lambda calculus
  where the $\operatorname{unbox}$ operator is parametric,
  in order to encompass all four modal lambda calculi of interest
  with a single calculus.
  With the parameter unifying $\operatorname{unbox}$ as a starting point,
  remaining parameters are identified in order to sufficiently define the calculus.
\item A normalization algorithm
  through the Normalization by Evaluation \cite{berger91} technique;
\item and a proof of its correctness.
\end{itemize}
The results have been mechanized\footnote{Available online at
\url{https://github.com/axelf4/pfm-lambda}.}
in Agda, providing a proof of their correctness;
most work has gone into writing these proofs.
The Agda code uses relatively few abstractions,
making it more approachable for those from outside the field.

The parametric calculus is more amenable to language extensions;
an extension only has to be implemented and proved correct once
for it to apply to all instantiated calculi.
Moreover, with all the commonalities of the four calculi extracted,
it becomes easier to talk about further generalization
to other calculi with additional axioms, such as axiom R.
This is discussed in the conclusion.

This thesis is structured as follows:
\autoref{sec:background} contains an overview of the theory underlying the work;
and \autoref{sec:calculus} and \autoref{sec:normalization}
present the main result of this thesis,
the parametric calculus and its accompanying normalization algorithm.
In \autoref{sec:correctness} the correctness of normalization is proved;
and \autoref{sec:instantiations} gives two concrete instantiations
of the parametric calculus.
Finally \autoref{sec:conclusion} concludes by discussing
relations to prior work and possible future work.

\chapter{Background}\label{sec:background}

In this chapter we summarize the necessary background knowledge
for understanding the rest of the material.

\section{Modal Natural Deduction}

Modalities originate from modal logic.
Here we consider the family of modal logics
derived from intuitionistic propositional logic
extended with the unary connective \Box{},
the inference rule \emph{necessitation},
if $A$ is provable without any premises then so is $\Box A$,
and different axioms surrounding \Box{} \cite{clouston18}.
For a formula $\phi$, the formula $\Box \phi$ reads
``It is necessarily true that $\phi$,''
that is, \Box{} changes the \emph{mode} of $\phi$.
The most basic modal logic, IK, comes from the \emph{axiom K}
($\Box (A \supset B) \supset \Box A \supset \Box B$).
Axiom K together with \emph{axiom T} ($\Box A \supset A$) gives IT;
K and \emph{axiom 4} ($\Box A \supset \Box\Box A$) yield IK4;
and K, T and 4 give IS4.

Natural deduction is a proof system
wherein reasoning is carried out using ``natural'' inference rules.
\textcite{fitch52} introduced a notation for propositional natural deduction,
central to which is the idea of \emph{subordinate proof}.
For example, in order to prove ``$A$ implies $B$,'' $A \supset B$,
a subordinate proof may be opened containing the new assumption $A$,
where one sets out to prove $B$.
If successful, the subordinate proof can be shut
by introducing $A \supset B$ in the original proof
thereby discharging the assumption $A$.

This may be understood semantically using Kripke's possible worlds interpretation
\cite{kripke63, huth04},
where each world has an assignment of truth-values to each proposition.
Opening a subproof means visiting a replica new world,
with an increase in knowledge owing to the new assumption,
and shutting means returning.

To extend natural deduction to modal logic,
Fitch added the notion of a \emph{strict} subordinate proof \cite{borghuis94},
see the example in \autoref{fig:ex-modal-nat-deduction},
indicated by a `\Box' to the left of the line delineating the subproof.
It is differentiated by not
introducing a new hypothesis for the antecedent of the implication.
Additionally,
strict subordinate proofs may access
prior derived formulas only of a certain shape
from proofs to which they are subordinate.
This is in contrast to ``ordinary'' subordinate proofs
wherein any previous formula from a outer proof may be reiterated.
This is how the mixing of formulas of different modes is prevented.
Their usage is given in the following two rules for the logic K:
\begin{equation*}
  \begin{array}{l@{\hskip 4em}l}
    \textsc{K-Import} & \textsc{K-Export} \\
    \begin{fitch*}
      \Box \varphi \\
      \vdotswithin{\Box \varphi} \\
      \fn \vdotswithin{\varphi} \\
      \fa \varphi
    \end{fitch*} &
    \begin{fitch*}
      \fn \vdotswithin{\varphi} \\
      \fa \varphi \\
      \Box \varphi
    \end{fitch*}
  \end{array}
\end{equation*}
With \textsc{K-Import} we may import boxed formulas,
but after we are done reasoning about them we must re-box the result
with \textsc{K-Export} to make use of it.

\begin{figure}
  \centering
    \begin{fitch}
      \fj \Box (A \supset B) \\
      \fa \fh \Box A \\
      \fa \fa \fn A \supset B & K-import, 1 \\
      \fa \fa \fa A & K-import, 2 \\
      \fa \fa \fa B & $\supset$-elim, 3, 4 \\
      \fa \fa \Box B & K-export, 3-5 \\
      \fa \Box A \supset \Box B & $\supset$-intro, 2-6 \\
      \Box (A \supset B) \supset (\Box A \supset \Box B) & $\supset$-intro, 1-7
    \end{fitch}
  \caption{Example of a modal natural deduction proof of the formula
    $\Box (A \supset B) \supset (\Box A \supset \Box B)$.
    Note how a strict subordinate proof must be opened
    in order to facilitate reasoning about that inside modalities.
    \label{fig:ex-modal-nat-deduction}}
\end{figure}

\section{Lambda Calculus}

The Curry-Howard isomorphism \cite{howard80} connects logic and lambda calculus,
a bare-bones model of computation
consisting of only functions and function application.
The grammar of lambda calculus terms is evidently short:
\begin{align*}
  t, s \Coloneqq& \, x &&\text{variable access} \\
  \mid& \, \lambda x.\, t &&\text{lambda abstraction} \\
  \mid& \, t \; s &&\text{function application}
\end{align*}
The isomorphism states that there is a correspondence between
formulae and their proofs in natural deduction,
and types and programs of lambda calculus, respectively.
Take the formula $A \supset A$ for instance,
which says that ``$A$ implies $A$.''
Proving the formula is analogous to giving a program of the type $A \to A$,
for any type $A$,
and one such program is $\lambda x.\, x$,
which implements the identity function.

Now, not all lambda calculus terms are meaningful,
e.g.\@ $x \; y$ when $x$ is not a lambda function.
Types are one way of allowing evaluation to nevertheless be total,
by restricting it to only \emph{well-typed} terms,
$\Gamma \vdash t : A$, for some type $A$.
The \emph{simply typed lambda calculus} (STLC) \cite{church40},
in addition to some set of base types,
has a single type constructor $A \to B$ for the types of functions.
Then, the \emph{typing relation} $\Gamma \vdash t : A$ is defined
in terms of a \emph{typing context} $\Gamma$,
which is an association of variables and their types,
and is used i.a.\@ in the function typing rule:
$\lambda x.\, y$ is a well-typed term of type $A \to B$ in context $\Gamma$,
if $y$ has type $B$ in the context $\Gamma$ extended with $x : A$.

The proof assistant Agda \cite{norell07}
is itself based on \emph{dependently typed} lambda calculus.
``Dependently'' meaning definitions of types may depend on values,
allowing one to state theorems about the results of functions.

\emph{Normalization by Evaluation} (NbE) is a technique for
reducing lambda calculus terms to their normal forms,
which are not further reducible \cite{berger91}.
Instead of implementing the normalization procedure ``by hand,''
you instead proceed by evaluating,
before \emph{reifying} the resulting semantic value back into a term.
If at any point computation is blocked on a value known only at run time,
e.g.\@ on an argument when descending into the body of a lambda abstraction,
evaluation proceeds with a so called \emph{neutral value},
containing enough information about its origins to make reification possible.

Modal logic has been adapted for modal lambda calculi \cite{borghuis94},
where modalities are type constructors that add some properties.
In place of the K inference rules, \textsc{K-Export} and \textsc{K-Import},
are two new operators $\operatorname{box}$ and $\operatorname{unbox}$ respectively.
To keep track of subordinate proofs in typing judgments
a new structural connective \lock{} is added to the context when a \Box{} is eliminated,
and popped when the subproof is closed.

\section{Example: Staged Computation}\label{sec:staged-computation}

For the twofold purpose of exemplifying the previous section,
and showing a practical application of the theory,
this section gives an account of the work by \textcite{davies01}
on leveraging the modal logic S4 for staged computation.

Consider the problem of run-time code generation due to partial function application.
For example, prior to a series of matrix multiplication with the same matrix,
the code for the multiplication could be specialized at run-time
once the matrix has been computed.
If it turns out to contain a lot of zeros then that may be exploited
to reduce the amount of computation needed.
Detecting where this may be done automatically at compile time
is similar to binding-time analysis in partial evaluation \cite{leone94}.
Each subexpression is annotated with its data dependencies
to detect whether it may be computed in an early stage
after only some function arguments have been applied.
However, in practice, automatic choice of where to do run-time specialization
may lead to slow-downs due to the non-negligible cost of code generation.
An alternative is to mandate that computation staging be explicitly expressed
in the type system.

The insight due to \cite{davies01} is that run-time code generation demands
a quoted source expression,
and quotation has been studied in modal logic,
with intuitionistic S4 being the logic that models staged computation.
We get the following interpretations of modal concepts
\begin{itemize}
\item Values of type $\Box A$ are code to be executed in future stage,
  and compiled to generators for code of type $A$.
\item The rule of necessitation,
  i.e.\@ we have $\operatorname{box} \; E : \Box A$ if $E : A$ in the empty context,
  says we may quote any closed expression.
\item Axiom T, $\Gamma \vdash \Box A \to A$, is evaluation.
  Specifically, the $\operatorname{unbox}$ constructor on values of type $\Box A$
  will do evaluation,
  and for values of types $\Box \cdots \Box A$ it can be used to splice the quoted expressions
  into a larger ones, so called \emph{quasiquotation}.
\item Axiom 4, $\Gamma \vdash \Box A \to \Box\Box A$, is requotation,
  producing code that generates the original code.
\item In general, we do \emph{not} have $\Gamma \vdash A \to \Box A$,
  since to quote a function its source code would need to be retrieved
  which is not possible for arbitrary functions.
  However, for example integers may be quoted to obtain integer literals,
  and similarly for Booleans, strings etc.
\end{itemize}
For a function $A \to \Box B$, the modal type guarantees all computation
concerning an argument $a : A$ is done while generating code for a value of type $B$.
Otherwise, to access $a$ in the generated code,
it must be manually quoted and inserted into the code.
In other words, the argument $a$ exists only in the function body that generates the code,
and is not automatically kept around with the generated code.

As an example, multiplication with run-time specialization may be written
in this framework as
\begin{center}
  \begin{tabular}{c}
    \begin{lstlisting}[mathescape=true,morekeywords={if,then,else,box,unbox},columns=flexible]
mult : $\mathbb N \to \Box (\mathbb N \to \mathbb N)$
mult = $\lambda$n : $\mathbb N$. if n = 0
    then box ($\lambda$m. 0)
    else box ($\lambda$m. m + unbox (mult (n - 1)) m)
    \end{lstlisting}
  \end{tabular}
\end{center}
Now multiplication by zero becomes a constant function
\begin{align*}
  \textit{mult} \; 0 \mapsto^* &\operatorname{box} \; (\lambda \_.\, 0)
  \intertext{and for other values, the entire \textit{mult} function is inlined}
  \textit{mult} \; 2 \mapsto^* &\operatorname{box} \; (\lambda x.\, x + (\lambda y.\, y + (\lambda z.\, 0) \; y) \; x) \\
  = &\operatorname{box} \; (\lambda x.\, x + (x + 0))
\end{align*}

\section{Previous Work}

There are at present two main variants of lambda calculi formulations
for the necessity modality.

The first variant is the dual-context style proposed by \textcite{pfenning95,davies01},
where two contexts, $\Psi; \Gamma$, are used to keep track of assumptions.
The context $\Psi$ holds the assumptions that are ``necessarily true,''
while $\Gamma$ maintains the true assumptions.
The introduction and elimination rules are
\begin{equation*}
  \inferrule{\Psi; \cdot \vdash t : A}{\Psi; \Gamma \vdash \operatorname{box} \; t : \Box A} \qquad
  \inferrule{\Psi; \Gamma \vdash t : \Box A \\ \Psi, x : A; \Gamma \vdash s : S}{\Psi; \Gamma \vdash \operatorname{letbox} \; x = t \; \operatorname{in} \; s : S}
\end{equation*}
The elimination rule destructures $\Box A$,
letting its content temporarily be necessarily true in $s$.
Reducing it done by applying a substitution:
$$ \operatorname{letbox} \; x = t \; \operatorname{in} \; s : S \sim s[x \mapsto t] $$

The second variant is Kripke- or Fitch style \cite{davies01,clouston18},
which models Kripke's possible worlds semantics \cite{kripke63}.
The worlds are connected via a \emph{modal accessibility relation}, $\Delta\lhd\Gamma$,
which should be construed as saying
``the contents of boxed values from the world $\Delta$
may be accessed in the future world $\Gamma$,''
as will become apparent upon seeing the corresponding \Box-elimination rule.
Imposing different properties on the relation yields different modal logics \cite{huth04}.
For example, a reflexive modal accessibility relation corresponds to logic T,
a transitive relation, to logic 4, etc.

Kripke style, presented by \textcite{pfenning95,davies01},
represents the previously accessed worlds as a stack of contexts,
$\vec\Gamma = \Gamma_1; \ldots; \Gamma_n$,
as opposed to Fitch style.
The \Box{} introduction and elimination rules look like
\begin{equation*}
  \inferrule{\vec\Gamma; \cdot \vdash t : A}{\vec\Gamma \vdash \operatorname{box} \; t : \Box A} \qquad
  \inferrule{\vec\Gamma \vdash t : \Box A \\ \vert\vec\Delta\rvert = n}{\vec\Gamma; \vec\Delta \vdash \operatorname{unbox}_n \; t : A} \qquad
\end{equation*}
where $\lvert\vec\Delta\rvert$ is the number of local contexts in the stack $\vec\Delta$.
The elimination rule takes an integer $n$ called the \emph{modal offset},
encoding how far back into the past to travel to access $t$ of type $\Box A$.
Adjusting the allowed values of $n$ gives different modal accessibility relations,
and ergo different modal logics.

\textcite{hu23} have given a normalization by evaluation proof for Kripke style modal lambda calculi.

Fitch style, on the other hand, its name stemming from Fitch-style natural deduction,
comes from \textcite{borghuis94} and \textcite{clouston18}.
It differs from Kripke style in that instead of a context stack, a flat list is used,
with local contexts delimited by a special `\lock' symbol.
The introduction and elimination rules are shown below in \autoref{sec:calculus}.

\textcite{valliappan22} implemented normalization for the four modal lambda calculi
$\lambda_\text{IK}$, $\lambda_\text{IT}$, $\lambda_\text{IK4}$, $\lambda_\text{IS4}$.
As they note, for the four calculi only the \Box-elimination rules differ,
see figure~\ref{fig:elim-rules}.
In this thesis, we use that concept to formulate
a single parametric calculus generalizing these four calculi,
with a \Box-elimination rule that is parametric over
the concrete modal accessibility relation in question.

\begin{figure}
  \begin{align*}
    &\inferrule[$\lambda_\text{IK}$/\Box-Elim]
    {\Gamma \vdash t : \Box A}
    {\Gamma, \lock, \Gamma' \vdash \unbox_{\lambda_\text{IK}} t : A}
    \; \lock \notin \Gamma' &
    &\inferrule[$\lambda_\text{IT}$/\Box-Elim]
          {\Gamma \vdash t : \Box A}
          {\Gamma, \Gamma' \vdash \unbox_{\lambda_\text{IT}} t : A}
          \; \#_{\lock} (\Gamma') \le 1 \\
          & \inferrule[$\lambda_\text{IK4}$/\Box-Elim]
            {\Gamma \vdash t : \Box A}
            {\Gamma, \lock, \Gamma' \vdash \unbox_{\lambda_\text{IK4}} t : A} &
            & \inferrule[$\lambda_\text{IS4}$/\Box-Elim]
            {\Gamma \vdash t : \Box A}
            {\Gamma, \Gamma' \vdash \unbox_{\lambda_\text{IS4}} t : A}
  \end{align*}
  \caption{\Box-elimination rules for the modal lambda calculi
    $\lambda_\text{IK}$, $\lambda_\text{IT}$, $\lambda_\text{IK4}$ and $\lambda_\text{IS4}$
    \cite{clouston18}.
    \label{fig:elim-rules}}
\end{figure}

\chapter{The Calculus \texorpdfstring{$\lambda_\text{PFM}$}{Lambda-PFM}}\label{sec:calculus}

In this chapter we give the specification of
the simply typed modal lambda calculus $\lambda_\text{PFM}$,
which is the main result of this thesis.
The calculus is parameterized by the binary relation $\Delta\lhd\Gamma$ on contexts,
subject to requirements that will be given below.

Types are constructed out of an uninterpreted base type $\iota$:
$$ \text{\emph{Type}} \quad A, B \Coloneqq \iota \mid A \to B \mid \Box A $$
The base type $\iota$ does not stipulate any introduction- nor elimination rules -
there simply has to be \emph{some} base type,
or else function- and box types would be unrepresentable.
Contexts are snoc-lists of types and locks:
$$ \text{\emph{Context}} \quad \Gamma \Coloneqq \cdot \mid \Gamma, A \mid \Gamma, \lock $$
The intrinsically typed syntax of the language is given in figure~\ref{fig:typing-rules}.
De Bruijn indices are used to make $\alpha$-conversion implicit:
Instead of variable names, an index at each variable occurrence
indicates the nesting depth relative to its corresponding binder,
for example
\vspace{.5\baselineskip}
\begin{equation*}
  \lambda x.\, (\lambda y.\, y \; (\lambda z.\, z)) \; (\lambda w.\, x \; w) \iff
  \tikznode{l1}{\lambda.}\, (\tikznode{l2}{\lambda.}\, \tikznode{x1}{0} \; (\tikznode{l3}{\lambda.}\, \tikznode{x2}{0})) \; (\tikznode{l4}{\lambda.}\, \tikznode{x3}{1} \; \tikznode{x4}{0})
  \tikz[remember picture,overlay,->]{
    \draw ([yshift=1mm] x1.north) -- ++(0,.4\baselineskip) -| (l2.north);
    \draw ([yshift=1mm] x2.north) -- ++(0,.4\baselineskip) -| (l3.north);
    \draw ([yshift=1mm] x3.north) -- ++(0,.75\baselineskip) -| (l1.north);
    \draw ([yshift=-1mm] x4.south) -- ++(0,-.4\baselineskip) -| ([yshift=-1mm] l4.south);
  }
\end{equation*}

\begin{figure}
  \centering
  \begin{align*}
    &\inferrule[Var]{x = \lvert\Gamma'\rvert}{\Gamma, A, \Gamma' \vdash x : A} \; \lock \notin \Gamma' &
    &\inferrule[\to-Intro]{\Gamma, A \vdash t : B}{\Gamma \vdash \lambda t : A \to B} &
    &\inferrule[\to-Elim]{\Gamma \vdash t : A \to B \\ \Gamma \vdash s : A}{\Gamma \vdash t \; s : B}
  \end{align*}
  \begin{align*}
    &\inferrule[\Box-Intro]{\Gamma, \lock \vdash t : A}{\Gamma \vdash \operatorname{box} t : \Box A} &
    &\inferrule[\Box-Elim]{\Delta \vdash t : A \\ \Delta \lhd \Gamma}{\Gamma \vdash \operatorname{unbox} t : A}
  \end{align*}
  \caption{The set of intrinsically typed terms of $\lambda_\text{PFM}$.
    The modal accessibility relation $\Delta\lhd\Gamma$ is a parameter of the calculus.
    \label{fig:typing-rules}}
\end{figure}

In order to present the equational theory
we define OPE:s and substitutions.

An \emph{order-preserving embedding} (OPE) is a binary relation $\Gamma \subseteq \Delta$ on contexts
signifying $\Gamma$ can be weakened, i.e.\@ add more assumptions,
to obtain $\Delta$.
It is defined inductively as
\begin{equation*}
  \inferrule{ }{\operatorname{base} : \cdot \subseteq \cdot} \quad
  \inferrule{\Gamma \subseteq \Delta}{\operatorname{weak} : \Gamma \subseteq \Delta, A} \quad
  \inferrule{\Gamma \subseteq \Delta}{\operatorname{lift} : \Gamma, A \subseteq \Delta, A} \quad
  \inferrule{\Gamma \subseteq \Delta}{\operatorname{lift}_\lock : \Gamma, \lock \subseteq \Delta, \lock}
\end{equation*}
We define a operation
$\operatorname{wk} : \Gamma\subseteq\Delta \to \Gamma \vdash t : A \to \Delta \vdash t : A$
that given an OPE weakens a term.
Only the case of weakening an $\operatorname{unbox}$ term is unlike the STLC counterpart:
$$ \textit{wk} \; w \; (\operatorname{unbox} \; t \; m) \coloneqq \operatorname{unbox} \; (\textit{wk} \; w' \; t) \; m' \quad \text{where } m' , w' = \textit{rewind}_\subseteq \; m \; w $$
where we require the calculus parameter
$$ \textit{rewind}_\subseteq : (m : \Gamma'\lhd\Gamma) \to (w : \Gamma\subseteq\Delta) \to \exists \Delta'. \, \Delta'\lhd\Delta \times \Gamma'\subseteq\Delta' $$
that given a modal accessibility relation $m$
truncates the contexts $\Gamma$ and $\Delta$ in $w$,
see figure~\ref{fig:rewind},
in order to remove as many locks from both as there are in $m$.
That is to say, it transports $w$ from the future world $\Gamma$ to instead act on the past world $\Gamma'$.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node (Γ) at (1,1) {$\Gamma$};
    \node (Γ') at (3,1) {$\Gamma\mathrlap'$};
    \node (Δ) at (0,0) {$\Delta$};
    \node (Δ') at (2,0) {$\Delta\mathrlap'$};
    \path (Γ) edge[->,bend left=15] node[above] {$\sigma$} (Γ')
    edge[-] node[auto=right] {$m$} (Δ)
    (Δ') edge[-,dashed] node[auto=right] {$m'$} (Γ')
    edge[<-,dashed,bend left=15] node[below] {$\sigma'$} (Δ);
  \end{tikzpicture}
  \caption{Intuition for the contexts involved in the $\textit{rewind}$ operation.
    We identify an OPE $\Gamma \subseteq \Gamma'$,
    or substitution $\operatorname{Sub} \Gamma \; \Gamma'$,
    as a map $\sigma$ on terms from the context $\Gamma$ to $\Gamma'$.
    Then, given a modal accessibility relation $m : \Delta \lhd \Gamma$,
    $\Delta$ being some past world,
    $\textit{rewind} \; m \; \sigma$ yields $\sigma'$ and $m'$
    for some context $\Delta'$.
    \label{fig:rewind}}
\end{figure}

For substitutions - and later environments - we note that both
can be seen as replacement lists of items for each type in a context.
Thus we choose to define them as concrete instances of a type $\Rpl_F$,\footnote{
Abbreviation of \emph{R}e\emph{pl}acement, which was chosen as an arbitrary continuation
of the sequence of synonyms starting with: Renaming, substitution, ...}
parametric over some function
$F : \textit{Type} \to \textit{Context} \to \textbf{Set}$
and defined inductively as
\begin{equation*}
  \inferrule{ }{\cdot : \Rpl_F \cdot \; \Delta} \quad
  \inferrule{\sigma : \Rpl_F \Gamma \; \Delta \\ x : F \; A \; \Delta}
            {\sigma, x : \Rpl_F \; (\Gamma, A) \; \Delta} \quad
  \inferrule{\sigma : \Rpl_F \Gamma \; \Delta \\ m : \Delta\lhd\Delta'}
            {\operatorname{lock} \sigma \; m : \Rpl_F \; (\Gamma, \lock) \; \Delta'}
\end{equation*}
This helps unify some of the calculus parameters,
and avoids having some parameters depend on
e.g.\@ the definition of terms which in turn depends on other parameters.
Substitutions may then be defined as
$\operatorname{Sub} \coloneqq \operatorname{Rpl}_F$
with $F \; A \; \Gamma \coloneqq \Gamma \vdash A$.

With the exception of the $\operatorname{lock}$ constructor
the definition of $\Rpl$ is as for substitutions in STLC.
Adding the alternate constructor
$\operatorname{lift}_\lock : \Rpl \Gamma \; \Delta \to \Rpl \; (\Gamma, \lock) \; (\Delta, \lock)$
to STLC substitutions would allow them to represent local substitutions
in any of the ``worlds'' delimited by locks in the context.
Instead, $\operatorname{lock}$ with an argument $m : \Delta\lhd\Delta'$
(as used in \cite{valliappan22})
makes it possible to unify substitutions and \emph{modal transformations},
where locks are removed and added from contexts as permitted by $(\lhd)$,
and which are needed to describe the effect of unboxing.

With this choice of $\operatorname{lock}$ we make use of the parameter
$$ \lhd_\lock : \forall\Gamma. \, \Gamma \lhd \Gamma, \lock $$
in order to be able to define the identity substitution
$\textit{id}_s : \forall\Gamma. \, \operatorname{Sub} \Gamma \; \Gamma$.

As for \textit{wk} in the case of OPE:s, we define
$\textit{subst} : \operatorname{Rpl} \Gamma \; \Delta \to \Gamma \vdash t : A \to \Delta \vdash t : A$,
using the parameter
$$ \textit{rewind} : (m : \Gamma'\lhd\Gamma) \to (\sigma : \operatorname{Rpl} \Gamma \; \Delta) \to \exists \Delta'. \, \Delta'\lhd\Delta \times \operatorname{Rpl} \Gamma' \; \Delta' $$

The equational theory of $\lambda_\text{PFM}$ is given in figure~\ref{fig:eq-theory},
where reflexivity, symmetry, transitivity and congruence rules,
which ensure that $(\sim)$ is an equivalence relation,
have been omitted.
The notation $t \sim s$ says that the terms $t$ and $s$
are equal up to the conversion.

\begin{figure}
  \centering
  \begin{align*}
    \llap{$\beta$ equivalence:}& \quad
    \inferrule{\Gamma, A \vdash t : B \\ \Gamma \vdash s : A}{(\lambda. \, t) \; s \sim \textit{subst} \; (\textit{id}_s , s) \; t} \quad
    \inferrule{\Delta, \lock \vdash t : A \\ m : \Delta \lhd \Gamma}{\unbox \; (\operatorname{box} t) \; m \sim \textit{subst} \; (\operatorname{lock} \textit{id}_s \; m) \; t} \\
    \llap{$\eta$ equivalence:}& \quad
    \inferrule{\Gamma \vdash t : A \to B}{t \sim \lambda. \, (\textit{wk} \; (\operatorname{weak} \textit{id}_\subseteq) \; t) \; (\operatorname{var} \operatorname{zero})} \quad
    \inferrule{\Gamma \vdash t : \Box A}{t \sim \operatorname{box} \; (\operatorname{unbox} t \; \lhd_\lock)}
  \end{align*}
  \caption{Equational theory of $\lambda_\text{PFM}$.
    The rules for lambda abstraction are as for STLC.
    In the $\lambda$-$\beta$-conversion rule,
    a singleton substitution, $\textit{id}_s , s$, is applied to $t$,
    replacing the zeroth variable with $s$
    and decrementing all other de Bruijn indices.
    \label{fig:eq-theory}}
\end{figure}

\section{Summary of Calculus Parameters}

Because calculus parameters have been introduced on a per-need basis,
this section collects all parameters thus far.
These are sufficient for stating the syntax,
and the semantics in \autoref{sec:normalization};
however, \autoref{sec:correctness} introduces a further set of parameters,
restricting the calculi that may be instantiated enough
such that it is possible to prove correctness.

\begin{itemize}
\item A modal accessibility relation $\Delta \lhd \Gamma$ between contexts
  is required;
\item and a context obtained by appending a new empty local context
  to some context $\Gamma$ should be related to $\Gamma$:
  $$ \lhd_\lock : \Gamma \lhd (\Gamma , \lock) $$
\item OPE:s can be rewound according to a modal accessibility relation:
  $$ \textit{rewind}_\subseteq : (m : \Gamma'\lhd\Gamma) \to (w : \Gamma\subseteq\Delta) \to \exists \Delta'. \, \Delta'\lhd\Delta \times \Gamma'\subseteq\Delta' $$
\item and similarly for $\operatorname{Rpl}$:s such as substitutions:
  $$ \textit{rewind} : (m : \Gamma'\lhd\Gamma) \to (\sigma : \operatorname{Rpl} \Gamma \; \Delta) \to \exists \Delta'. \, \Delta'\lhd\Delta \times \operatorname{Rpl} \Gamma' \; \Delta' $$
\end{itemize}

\chapter{Normalization Algorithm}\label{sec:normalization}

We provide a Normalization by Evaluation algorithm based on a possible worlds model
for the parametric calculus in \autoref{sec:calculus}.
Normal and neutral forms are defined mutually as:
\begin{gather*}
  \inferrule{x : \text{Ne} \; \Gamma \; \iota}{\operatorname{ne} x : \text{Nf} \; \Gamma \; \iota} \quad
  \inferrule{x : \text{Nf} \; (\Gamma, A) \; B}{\operatorname{abs} x : \text{Nf} \; \Gamma \; (A \to B)} \quad
  \inferrule{x : \text{Nf} \; (\Gamma, \lock) \; A}{\operatorname{box} x : \text{Nf} \; \Gamma \; (\Box A)} \\
  \inferrule{x : A \in \Gamma}{\operatorname{var} x : \text{Ne} \; \Gamma \; A} \quad
  \inferrule{x : \text{Ne} \; \Gamma \; (A \to B) \\ y : \text{Nf} \; \Gamma \; A}{x \; y : \text{Ne} \; \Gamma \; B} \quad
  \inferrule{x : \text{Ne} \; \Delta \; (\Box A) \\ m : \Delta\lhd\Gamma}{\operatorname{unbox} x \; m : \text{Ne} \; \Gamma \; A}
\end{gather*}
The normal forms are $\beta$-normal - no $\beta$-reductions are possible -
and $\eta$-long - all variables are maximally applied and unboxed,
as the $\operatorname{ne}$ constructor only permits neutral values of the base type.

As done in \cite{valliappan22}, we choose contexts for worlds,
OPE:s for the intuitionistic accessibility relation between worlds, and
$(\lhd)$ for the modal accessibility relation.
(The intuitionistic accessibility relation should be thought of as
relating two worlds $w_1$ and $w_2$ if $w_2$ has as much or more knowledge than $w_1$;
for worlds as contexts this means all assumptions in $w_1$ should be present in $w_2$ too.)
Then we interpret types in the model as
\begin{equation}\label{eq:sem-values}
  \begin{split}
  \llbracket \iota \rrbracket_\Gamma &\coloneqq \text{Nf} \; \Gamma \; \iota \\
  \llbracket A \to B \rrbracket_\Gamma &\coloneqq \forall \Delta. \, \Gamma \subseteq \Delta \to \llbracket A \rrbracket_\Delta \to \llbracket B \rrbracket_\Delta \\
  \llbracket \Box A \rrbracket_\Gamma &\coloneqq \forall \Gamma', \Delta. \, \Gamma \subseteq \Gamma' \to \Gamma'\lhd\Delta \to \llbracket A \rrbracket_\Delta
  \end{split}
\end{equation}
and contexts as environments, i.e.\@ lists of semantic values, using $\operatorname{Rpl}$,
$$ \llbracket \Gamma \rrbracket_\Delta \coloneqq \operatorname{Rpl}_{\llbracket-\rrbracket} \Gamma \; \Delta $$
We have monotonicity for semantic values and environments,
i.e.\@ we have
$wk_A : \Delta \subseteq \Delta' \to \llbracket A \rrbracket_\Delta \to \llbracket A \rrbracket_\Delta'$ and
$wk_\Gamma : \Delta \subseteq \Delta' \to \llbracket \Gamma \rrbracket_\Delta \to \llbracket \Gamma \rrbracket_\Delta'$.

The definition of evaluation, reification and reflection is given in figure~\ref{fig:nbe}.
Variable lookup is as for STLC -
the \textsc{Var} rule does not permit access across lock delimiters in the context,
thus the $\operatorname{lookup}$ function just has to read
the variable value from its place in the local environment.
The normalization function may then be given as
\begin{definition}[Normalization by Evaluation]
  Given a term $\Gamma \vdash t : A$,
  normalization yields a normal form $\operatorname{Nf} \; \Gamma \; A$,
  $$ \textit{nf} \; t \coloneqq \, \downarrow^A (\llbracket t \rrbracket \; \textit{id}_e) $$
  where $\textit{id}_e$ is the identity environment,
  which associates each variable $x$ in $\Gamma$
  with a value given by $\uparrow \operatorname{var} x$.
\end{definition}
The algorithm can be summarized as follows:
Evaluation proceeds as for an interpreter,
except closures take an extra OPE argument -
this allows conjuring fresh variables under binders
when reifying functions.
Then the resulting semantic value is reified back to its normal form.
When reifying a box or function,
evaluation resumes with the boxed term,
or the closure applied to a neutral form corresponding to the argument type,
respectively.

\begin{figure}
  \centering
  \begin{align*}
    &\mathrlap{\text{Evaluation} \quad \llbracket-\rrbracket : \Gamma \vdash t : A \to \forall\Delta. \, \llbracket\Gamma\rrbracket_\Delta \to \llbracket A \rrbracket_\Delta} &&\\
    &\llbracket x \rrbracket \; \gamma &&\coloneqq \text{lookup } x \text{ in } \gamma \\
    &\llbracket \lambda. \, t \rrbracket \; \gamma &&\coloneqq \lambda w \; \hat a.\, \llbracket t \rrbracket \; (\operatorname{wk}_{\widehat\Gamma} w \; \gamma, \hat a) \\
    &\llbracket t \; s \rrbracket \; \gamma &&\coloneqq \llbracket t \rrbracket \; \gamma \; \textit{id}_\subseteq \; (\llbracket s \rrbracket \; \gamma) \\
    &\llbracket \operatorname{box} t \rrbracket \; \gamma &&\coloneqq \lambda w \; m.\, \llbracket t \rrbracket \; (\operatorname{lock} \; (\operatorname{wk}_{\widehat\Gamma} w \; \gamma) \; m) \\
    &\llbracket \operatorname{unbox} t \; m \rrbracket \; \gamma &&\coloneqq \llbracket t \rrbracket \; \gamma' \; \textit{id}_\subseteq \; m' \quad \text{where } m' , \gamma' = \textit{rewind} \; m \; \gamma \\
    &\mathrlap{\text{Reification} \quad \downarrow^A : \llbracket A \rrbracket_\Gamma \to \operatorname{Nf} \; \Gamma \; A} &&\\
    &\downarrow^\iota a &&\coloneqq a \\
    &\downarrow^{A \to B} a &&\coloneqq \operatorname{abs} \; (\downarrow^B (a \; (\operatorname{weak} \textit{id}_\subseteq) \; (\uparrow^A (\operatorname{var} \operatorname{zero})))) \\
    &\downarrow^{\Box A} a &&\coloneqq \operatorname{box} \; (\downarrow^A (a \; \textit{id}_\subseteq \; \lhd_\lock)) \\
    &\mathrlap{\text{Reflection} \quad \uparrow^A : \operatorname{Ne} \; \Gamma \; A \to \llbracket A \rrbracket_\Gamma} &&\\
    &\uparrow^\iota x &&\coloneqq \operatorname{nt} x \\
    &\uparrow^{A \to B} x &&\coloneqq \lambda w \; a.\, \uparrow^B ((\operatorname{wk}_{\operatorname{Ne}} w \; x) \; (\downarrow^A a)) \\
    &\uparrow^{\Box A} x &&\coloneqq \lambda w \; m.\, \uparrow^B (\operatorname{unbox} \; (\operatorname{wk}_{\operatorname{Ne}} w \; x) \; m)
  \end{align*}
  \caption{Evaluation, reification and reflection definitions. \label{fig:nbe}}
\end{figure}

Here the possible worlds inspired interpretation of $\Box A$ has been chosen,
instead of the syntax-directed approach of
$$ \llbracket \Box A \rrbracket_\Gamma = \llbracket A \rrbracket_{\Gamma, \lock} $$
one reason being that the $\unbox$ case of evaluation then would require
being able to apply the equivalent of a $\operatorname{lock} \textit{id} \; m$ substitution
on semantic values, in addition to weakening,
whereas currently no such thing is needed,
as the $m$ instead goes directly in $\unbox$ when reflecting.

\chapter{Correctness}\label{sec:correctness}

Soundness and completeness of normalization
have been proved with respect to possible worlds,
which together show that the syntax in \autoref{sec:calculus},
and the semantics in \autoref{sec:normalization}
are ``in agreement''.

First off, we define the composition of two $\operatorname{Rpl}$:s, which,
while not appearing in the normalization algorithm,
is used in the proof of its correctness.
\begin{definition}[Composition of $\operatorname{Rpl}$:s]\label{def:composition}
  For $\sigma : \operatorname{Rpl}_F \Gamma \; \Delta$
  and $\delta : \operatorname{Rpl}_G \Delta \; \Xi$,
  $F$ not necessarily equaling $G$,
  their composition $\sigma \circ \delta : \operatorname{Rpl}_G \Gamma \; \Xi$
  is given by
  \begin{align*}
    \cdot \circ \delta &\coloneqq \cdot \\
    (\sigma , a) \circ \delta &\coloneqq (\sigma \circ \delta) , \textit{apply} \; \delta \; a \\
    \operatorname{lock} \sigma \; m \circ \delta &\coloneqq \operatorname{lock} \; (\sigma \circ \delta') \; m'
    \quad \text{where } m' , \delta' = \textit{rewind} \; m \; \delta
  \end{align*}
  where the definition is generic over a function
  $\textit{apply} : \forall A \; \Gamma \; \Delta.\, \operatorname{Rpl}_G \Gamma \; \Delta \to F \; A \; \Gamma \to G \; A \; \Delta$.
  E.g.\@ for composition of substitutions with substitutions
  $\textit{apply}$ will be $\textit{subst}$.
\end{definition}
As the source context $\Gamma$ of $\sigma \circ \delta$ is the same as for $\sigma$,
composition will preserve the inductive shape of $\sigma$,
but differ i.a.\@ in the $(-,-)$ constructor contents
where $\delta$ is $\textit{apply}$:ed.

Next, we introduce the following additional calculus parameters,
with which correctness has been proved:
\begin{itemize}
\item Rewinding $\operatorname{lock} \sigma \; m$
  with a modal accessibility relation $\Gamma \lhd \Gamma, \lock$
  should work as expected, i.e.\@ give back $m$ and $\sigma$:
  $$ \textit{rewind-$\lhd_\lock$} : \forall m, \sigma. \, \textit{rewind} \lhd_\lock (\operatorname{lock} \sigma \; m) \equiv m , \sigma $$
  and the same for $\textit{rewind}_\subseteq$ on $\operatorname{lift}_\lock$.
\item The operation $\textit{rewind}$ distributes over composition:
  \begin{equation}\label{eq:rewindPres-circ}
    \begin{split}
      \textit{rewindPres-$\circ$} &: (m : \Delta\lhd\Gamma) \to (\sigma_1 : \operatorname{Rpl} \Gamma \; \Gamma') \to (\sigma_2 : \operatorname{Rpl} \Gamma' \; \Gamma'') \\
      &\to
      \begin{array}[t]{@{}l@{}l@{}}
        \text{let } & m' , \sigma_1' = \textit{rewind} \; m \; \sigma_1 \\
        & m'' , \sigma_2' = \textit{rewind} \; m' \; \sigma_2 \\
        \text{in } & \textit{rewind} \; m \; (\sigma_1 \circ \sigma_2) \equiv m'' , \sigma_1' \circ \sigma_2'
      \end{array}
    \end{split}
  \end{equation}
  and likewise for $\textit{rewind}_\subseteq$.
\item $\textit{rewind}$ should preserve identity:
  $$ \textit{rewindPresId} : (m : \Delta\lhd\Gamma) \to \textit{rewind} \; m \; \textit{id} \equiv m , \textit{id} $$
  and likewise for $\textit{rewind}_\subseteq$.

  The parameter \textit{rewindPresId} further only has to hold for values of $F$ for which
  $\operatorname{Rpl}_F$-weakening with the identity OPE is the identity function, i.e.
  $$ \textit{wk}_{\operatorname{Rpl}_F} \; \textit{id}_\subseteq \; \sigma = \sigma $$
  for all $\sigma : \operatorname{Rpl}_F \; \Gamma \; \Delta$.
\item $\textit{rewind}$ should commute with weakening and substitution composition:
  \begin{align*}
    &\textit{rewindWk} &&: (m : \Delta\lhd\Gamma) \to (\sigma : \operatorname{Rpl} \Gamma \; \Gamma') \to (w : \Gamma' \subseteq \Gamma'') \\
    &&&\to
    \begin{array}[t]{@{}l@{}l@{}}
      \text{let } & m' , \sigma' = \textit{rewind} \; m \; \sigma \\
      & m'' , w' = \textit{rewind}_\subseteq \; m' \; w \\
      \text{in } & \textit{rewind} \; m \; (\textit{wk} \; w \; \sigma) \equiv m'' , \textit{wk} \; w' \; \sigma'
    \end{array} \\
    &\textit{rewindTrim} &&: (m : \Delta\lhd\Gamma) \to (w : \Gamma \subseteq \Gamma') \to (\sigma : \operatorname{Rpl} \Gamma' \; \Gamma'') \\
    &&&\to
    \begin{array}[t]{@{}l@{}l@{}}
      \text{let } & m' , w' = \textit{rewind}_\subseteq \; m \; w \\
      & m'' , \sigma' = \textit{rewind} \; m' \; \sigma \\
      \text{in } & \textit{rewind} \; m \; (\textit{trim} \; w \; \sigma) \equiv m'' , \textit{trim} \; w' \; \sigma'
    \end{array}
  \end{align*}
  where $\textit{wk} : \Delta\subseteq\Delta' \to \operatorname{Sub} \Gamma \; \Delta \to \operatorname{Sub} \Gamma \; \Delta'$ and
  $\textit{trim} : \Gamma\subseteq\Gamma' \to \operatorname{Sub} \Gamma \; \Delta \to \operatorname{Sub} \Gamma' \; \Delta$
  is substitution and weakening composition and vice versa, respectively.
\end{itemize}
These enable proving of the necessary weakening and substitution laws,
such as associativity of composition,
and the fact that \textit{subst} with the identity substitution is the identity function.
Indeed, most show up in the goals when proving the $\operatorname{unbox}$ cases of the laws.

The reader is reminded that the full details of any proof
are available in the provided Agda code.

\section{Soundness}

Soundness states that a term is convertible to its normal form.
\begin{theorem}[Soundness]
  If $\Gamma \vdash t : A$, then $t \sim \ulcorner \textit{nf} \; t \urcorner$.
\end{theorem}

The proof is an extension of the corresponding proof for STLC \cite{kovacs17},
and established by a \emph{Kripke logical relation} \cite{plotkin73}
between terms and semantic values:
\begin{align*}
  (\simeq^A) &\subseteq \Gamma \vdash A \times \llbracket A \rrbracket_\Gamma \\
  t \simeq^\iota \hat t &\coloneqq t \sim \ulcorner \hat t \urcorner \\
  t \simeq^{A \to B} \hat t &\coloneqq (w : \Gamma \subseteq \Delta) \to \forall a : \Delta \vdash A, \hat a : \llbracket A \rrbracket_\Delta.\, a \simeq \hat a \\
  &\qquad \to \operatorname{app} \; (\textit{wk} \; w \; t) \; a \simeq \hat t \; w \; \hat a \\
  t \simeq^{\Box A} \hat t &\coloneqq (w : \Gamma \subseteq \Gamma') \to (m : \Gamma' \lhd \Delta)
  \to \operatorname{unbox} \; (\textit{wk} \; w \; t) \; m \simeq \hat t \; w \; m
\end{align*}
It is \emph{logical} in the sense that terms and semantic values of box/function types
are related iff the results from unboxing/applying both to related terms and values, are related;
``Kripke'' means that we may first extend the context with a weakening.
Notice how the definition of the logical relation has the same shape
as that of semantic values, see equation \eqref{eq:sem-values}.
We will prove for each inductive step of normalization that $(\simeq)$ is maintained;
just as $\textit{nf}$ always returns a normal form through reification,
after reification we will get a $(\sim)$ out of $(\simeq)$.

We extend $(\simeq)$ to a relation $(\simeq_\text{ctx})$
between substitutions and environments elementwise related by $(\simeq)$,
and show that
the interpretations of a term in related substitutions and environments are related,
the so called \emph{fundamental theorem} of the logical relation:
\begin{lemma}[Fundamental theorem]
  If $t : \Gamma \vdash A$, $\sigma : \operatorname{Sub} \; \Gamma \; \Delta$,
  $\delta : \operatorname{Env} \; \Gamma \; \Delta$
  and $\sigma \simeq_\text{ctx} \delta$,
  then $\textit{subst} \; \sigma \; t \simeq \llbracket t \rrbracket \; \delta$.
\end{lemma}
\begin{proof}
  By induction on $t$.
  For the case of $t = \operatorname{box} \; s$, it needs to be shown that for all
  $w : \Delta \subseteq \Delta'$, $m : \Delta' \lhd \Xi$,
  \begin{equation*}
    \operatorname{unbox} \; (\operatorname{box} \; (\textit{wk} \; (\operatorname{lift}_\lock \; w) \; (\textit{subst} \; (\operatorname{lock} \; \sigma \; \lhd_\lock) \; s)))
    \simeq \llbracket s \rrbracket \; (\operatorname{lock} \; (\textit{wk} \; w \; \delta) \; m)
  \end{equation*}
  The induction hypothesis gives
  $$ \textit{subst} \; (\operatorname{lock} \; (\textit{wk} \; w \; \sigma) \; m) \; s \simeq \llbracket s \rrbracket \; (\operatorname{lock} \; (\textit{wk} \; w \; \delta) \; m) $$
  which we compose with a conversion proof on the left
  \begin{equation*}
    \begin{split}
      &\Box\text{-}\beta \; (\textit{wk} \; (\operatorname{lift}_\lock \; w) \; (\textit{subst} \; (\operatorname{lock} \; \sigma \; \lhd_\lock) \; s)) \; m \\
      &\quad : \operatorname{unbox} \; (\operatorname{box} \; (\textit{wk} \; (\operatorname{lift}_\lock \; w) \; (\textit{subst} \; (\operatorname{lock} \; \sigma \; \lhd_\lock) \; s))) \\
      &\qquad \sim \textit{subst} \; (\operatorname{lock} \; \textit{id} \; m) \; (\textit{wk} \; (\operatorname{lift}_\lock \; w) \; (\textit{subst} \; (\operatorname{lock} \; \sigma \; \lhd_\lock) \; s))
    \end{split}
  \end{equation*}
  Here the term on the right side of $(\sim)$ does not immediately match up
  with the left side of $(\simeq)$ in the IH,
  however one can show that they are in fact equal
  using $\textit{rewind-/rewind$_\subseteq$-}\lhd_\lock$ and substitution laws.

  For the $t = \operatorname{unbox} \; s \; m$ case,
  it suffices to rewind the proof of $\sigma\simeq_\text{ctx}\delta$ by $m$ to get
  $$ \textit{rewind} \; m \; \sigma \simeq_\text{ctx} \textit{rewind} \; m \; \delta $$
  and apply the IH on it and $s$.
\end{proof}

Similarly, we show that reification and reflection also respect $(\simeq)$:
\begin{lemma}
  Reification and reflection respect $(\simeq)$:
  \begin{enumerate}
    \renewcommand{\theenumi}{\alph{enumi}}
  \item If $t : \Gamma \vdash A$, $\hat t : \llbracket A \rrbracket_\Gamma$
    and $t \simeq \hat t$ then $t \sim \ulcorner \downarrow\hat t \urcorner$.
  \item If $t : \operatorname{Ne} \Gamma \; A$ then $\ulcorner t \urcorner \simeq \, \uparrow t$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By induction on $A$.
  (Only the $\Box A$ case of (a) is shown here,
  with the rest left to the formalization.)
  The proof of $t \simeq \hat t$ says unboxing of $t$ and $\hat t$ respects $(\simeq)$.
  Choosing $w = \textit{id}_\subseteq$ and $m = \lhd_\lock$
  and applying the IH on the result yields
  $$ \operatorname{unbox} \; (\textit{wk} \; \textit{id}_\subseteq \; t) \; \lhd_\lock \simeq \ulcorner \downarrow (\hat t \; \textit{id}_\subseteq \; \lhd_\lock) \urcorner $$
  where $\textit{wk} \; \textit{id}_\subseteq \; t = t$.
  Combining this with the $\Box\text{-}\eta$ conversion rule for $t$, i.e.
  $$ t \sim \operatorname{box} \; (\operatorname{unbox} \; t \; \lhd_\lock) $$
  using transitivity and congruence under $\operatorname{box}$
  of the conversion relation gives the goal.
\end{proof}

The fundamental theorem,
using $\textit{id}_s$ and $\textit{id}_e$ for substitution and environment,
may then be combined with the reification lemma
to conclude the soundness proof.

One detail remains, however.
Depending on how $(\simeq_\text{ctx})$ is defined it may not be possible to rewind it.
We know only how to rewind OPE:s and $\operatorname{Rpl}$:s,
not arbitrary data types, without taking more rewind functions as parameters.
Thus we let $(\simeq_\text{ctx}) \coloneqq \operatorname{Rpl}_{A\simeq\widehat A}$ where
$$ A\!\simeq\!\widehat A \; A \; \Gamma \coloneqq \exists t : \Gamma \vdash A, \hat t : \llbracket A \rrbracket_\Gamma.\, t \simeq \hat t $$
is triplet of a term, a semantic value, and a proof that the two are related.
The substitution may be recouped by mapping the $\operatorname{Rpl}$
with a function that picks the $t$ out of each $A\!\simeq\!\widehat A$,
likewise for the environment.
For the proof of the $\operatorname{unbox}$ case of the fundamental theorem,
an additional calculus parameter is needed:
\begin{itemize}
\item Rewind should commute with $\textit{map}_{\operatorname{Rpl}}$:
  \begin{multline*}
  \textit{rewindCommMap} : \forall (f : \forall A, \Gamma.\, F \; A \; \Gamma \to G \; A \; \Gamma), m, \sigma : \operatorname{Rpl}_F \; \Gamma \; \Delta. \\
  \pi_1 \; (\textit{rewind} \; m \; \sigma) \equiv \pi_1 \; (\textit{rewind} \; m \; (\textit{map} \; f \; \sigma)) \\
  \land \textit{map} \; f \; (\pi_2 \; (\textit{rewind} \; m \; \sigma)) \equiv \pi_2 \; (\textit{rewind} \; m \; (\textit{map} \; f \; \sigma))
  \end{multline*}
  where $\pi_1$ and $\pi_2$ is the first and second projections of the product type.
\end{itemize}
The parameter $\textit{rewindCommMap}$ enables us
to get the rewound substitution/environment
from a rewound proof of $\sigma \simeq_\text{ctx} \delta$.
It should be noted that we expect the equivalence to hold a priori,
since a $\textit{rewind}$ instantiation cannot observe
the contents of the parametric $\operatorname{Rpl}$,
which is the only thing $\textit{map}_{\operatorname{Rpl}}$ modifies,
as explained in \citetitle{wadler89} \cite{wadler89}.
We still need to take it as a parameter, however, in order to convince Agda.

\section{Completeness}

For two convertible terms,
completeness expresses that normalization maps them to the same normal form.
\begin{theorem}[Completeness]
  If $t \sim t'$, then $\textit{nf} \; t = \textit{nf} \; t'$.
\end{theorem}

The standard technique for proving completeness of STLC \cite{altenkirch95,kovacs17}
uses a so called \emph{presheaf model},
where terms are interpreted as \emph{natural transformations}
between semantic contexts and semantic types.
Concretely, what needs to be changed in order to ensure
our possible worlds model is also a presheaf model,
is to add \emph{naturality} conditions to the interpretation of types.
Recall the interpretation of box types from equation \eqref{eq:sem-values}:
$$ \llbracket \Box A \rrbracket_\Gamma \coloneqq \forall \Gamma', \Delta. \, \Gamma \subseteq \Gamma' \to \Gamma'\lhd\Delta \to \llbracket A \rrbracket_\Delta $$
We constrain each box value $\hat a : \llbracket \Box A \rrbracket_\Gamma$
(and similarly for function values),
to fulfill for all $w : \Gamma \subseteq \Gamma'$, $m : \Gamma' \lhd \Delta$ and $w' : \Delta \subseteq \Delta'$,
$$ \hat a \; (w \circ w'') \; m' = \textit{wk}_{\widehat A} \; w' \; (\hat a \; w \; m) \quad \text{where } m' , w'' = \textit{rewind}_\subseteq \; m \; w' $$
i.e.\@ semantic boxes should commute with weakenings.
This allows us to prove naturality for evaluation, reification and reflection.

For proving completeness, since normalization is evaluation followed by reification,
it suffices to show the following lemma:
\begin{lemma}[Evaluation is sound w.r.t. conversion]
  Given two terms $\Gamma \vdash t, t' : A$ such that $t \sim t'$
  and an environment $\gamma : \operatorname{Env} \; \Gamma \; \Delta$,
  we have
  $$ \llbracket t \rrbracket \; \gamma = \llbracket t' \rrbracket \; \gamma $$
\end{lemma}
The proof is by induction on $t \sim t'$.
The $\Box\text{-}\eta$ equivalence case -
where $t'$ is equal to $\operatorname{box} \; (\operatorname{unbox} \; t \; \lhd_\lock)$ -
follows from naturality of evaluation and $\textit{rewind-}\lhd_\lock$.
(Though, since box types are interpreted as functions
of a weakening and modal accessibility relation,
we must first postulate function extensionality
in order to only have to show pointwise equality.)

For $\Box\text{-}\beta$ equivalence it needs to be shown that
$$ \llbracket t \rrbracket \; (\operatorname{lock} \; (\textit{wk}_{\widehat\Gamma} \; \textit{id}_\subseteq \; \gamma') \; m') = \llbracket \textit{subst} \; (\operatorname{lock} \; \textit{id}_s \; m) \; t \rrbracket \; \gamma $$
where $m' , \gamma' = \textit{rewind} \; m \; \gamma$.
We accomplish this using the fact that evaluating a substituted term
is the same as evaluating the raw term in a modified environment,
as summarized in the following lemma:
\begin{lemma}[Action of evaluation on substituted terms]
  If $\Gamma \vdash t : A$, $\sigma : \operatorname{Sub} \; \Gamma \; \Delta$
  and $\gamma : \operatorname{Env} \; \Delta \; \Xi$, then
  $$ \llbracket \textit{subst} \; \sigma \; t \rrbracket \; \gamma = \llbracket t \rrbracket \; (\sigma \circ \gamma) $$
\end{lemma}
Here the fact that composition between $\operatorname{Rpl}$:s of different types is defined,
see definition~\ref{def:composition}, comes into play,
where we let $\textit{apply} \coloneqq \lambda \gamma \; t.\, \llbracket t \rrbracket \; \gamma$ be evaluation
in order to compose substitutions and environments.
After applying the lemma it remains to show
$$ \llbracket t \rrbracket \; (\operatorname{lock} \; (\textit{wk}_{\widehat\Gamma} \; \textit{id}_\subseteq \; \gamma') \; m') = \llbracket t \rrbracket \; (\operatorname{lock} \; (\textit{id}_s \circ \gamma') \; m') $$
which follows from
$wk_e \; \textit{id}_\subseteq \; \gamma = \gamma = \textit{id}_s \circ \gamma$.

\chapter{Concrete Instantiations}\label{sec:instantiations}

In this chapter we give instantiations of $\lambda_\text{PFM}$
for the two concrete modal lambda calculi highlighted in \cite{valliappan22}.
It is worth mentioning that the two resulting calculi are correct by construction,
due to the correctness proof of the parametric calculus in \autoref{sec:correctness}.

\section{Intuitionistic K}\label{sec:ik}

To obtain $\lambda_\text{IK}$ we let the modal accessibility relation,
$\Delta \lhd_{\lambda_\text{IK}} \Gamma$, be as in \autoref{fig:ik-m},
i.e.\@ $\Gamma$ is an extension of $\Delta, \lock$ to the right without adding locks.
The $\lhd_\lock$ parameter is given by the base case, $\operatorname{base}$, of the relation.

\begin{figure}
  \centering
  \begin{equation*}
    \inferrule{}{\operatorname{base} : \Gamma \lhd_{\lambda_\text{IK}} \Gamma, \lock} \qquad
    \inferrule{m : \Delta \lhd_{\lambda_\text{IK}} \Gamma}{\operatorname{snoc} m : \Delta \lhd_{\lambda_\text{IK}} \Gamma, A}
  \end{equation*}
  \caption{Modal accessibility relation for $\lambda_\text{IK}$. \label{fig:ik-m}}
\end{figure}

The implementations of $\textit{rewind}_\subseteq$ and \textit{rewind}
by pattern-matching are both straightforward:
\begin{equation*}
  \begin{array}{llll}
    \textit{rewind}_\subseteq &m &(\operatorname{weak} w) &\coloneqq \operatorname{snoc} m' , w' \quad \text{where } m' , w' = \textit{rewind}_\subseteq \; m \; w \\
    \textit{rewind}_\subseteq &(\operatorname{snoc} m) &(\operatorname{lift} w) &\coloneqq \operatorname{snoc} m' , w' \quad \text{where } m' , w' = \textit{rewind}_\subseteq \; m \; w \\
    \textit{rewind}_\subseteq &\operatorname{base} &(\operatorname{lift}_\lock \; w) &\coloneqq \operatorname{base} , w
  \end{array}
\end{equation*}
and
\begin{equation}\label{eq:ik-rewind}
  \begin{array}{llll}
    \textit{rewind} &\operatorname{base} &(\operatorname{lock} \sigma \; m') &\coloneqq m' , \sigma \\
    \textit{rewind} &(\operatorname{snoc} \; m) &(\sigma , \_) &\coloneqq \textit{rewind} \; m \; \sigma
  \end{array}
\end{equation}
where the each inductive step pops one snoc layer from
the modal accessibility relation, and OPE or $\operatorname{Rpl}$ respectively,
in tandem until reaching the base case.
The exception is the $\operatorname{weak}$ OPE constructor which is skipped past.
In the inductive cases of $\textit{rewind}_\subseteq$,
the returned $m'$ is built up with $\operatorname{snoc}$,
such that for an OPE $\Gamma \subseteq \Delta$,
$m'$ will relate the target context $\Delta$ and its rewound parallel;
for \textit{rewind} that information is entirely in the $\operatorname{lock}$ constructor instead.

All the remaining parameters are trivial -
it suffices to case split on the possible constructors of ($\lhd_{\lambda_\text{IK}}$)
and the OPE or $\operatorname{Rpl}$,
until Agda confirms the parameter holds definitionally in the base cases,
applying the induction hypothesis elsewhere -
with the exception of \textit{rewindPresId} where we need an additional lemma:
\begin{lemma}
  If $\sigma : \operatorname{Rpl} \Gamma \; \Gamma'$ such that
  $\textit{wk}_{\operatorname{Rpl}} \; \textit{id}_\subseteq \; \sigma = \sigma$,
  then for all $m : \Delta \lhd_{\lambda_\text{IK}} \Gamma$
  $$ \textit{rewind} \; m \; (\textit{drop} \; \sigma) = \operatorname{snoc} m' , \sigma' \quad \text{where } m' , \sigma' = \textit{rewind} \; m \; \sigma $$
  where $\textit{drop} \coloneqq \textit{wk}_{\operatorname{Rpl}} \; (\operatorname{weak} \; \textit{id}_\subseteq)$
  weakens $\sigma$ by appending an additional assumption to the target context $\Gamma'$.
\end{lemma}
\begin{proof}
  The $\lambda_\text{IK}$ modal accessibility relation $m$,
  viewed as a context extension from $\Delta$ to $\Gamma$,
  starts with a \lock{} (see the $\operatorname{base}$ constructor).
  The function \textit{drop} only affects the part of $\sigma$
  pertaining to that right of the lock,
  which will be removed by the \textit{rewind} operation.
\end{proof}

\section{Intuitionistic S4}

For $\lambda_\text{IS4}$, the modal accessibility relation,
which has to be reflexive and transitive \cite{huth04},
is succinctly defined as
$\Delta \lhd \Gamma \coloneqq \exists \Xi.\, (\Gamma = \Delta, \Xi)$,
i.e.\@ the existence of a context extension from $\Delta$ to $\Gamma$,
as done by \textcite{valliappan22},
except it makes \textit{rewindPresId} impossible to implement without modifications.
The reason for this is that the argument made in \autoref{sec:ik}
for the \textit{rewindPresId} parameter of $\lambda_\text{IK}$,
does not apply here as the $(\lhd)$ in question does not necessarily start with a \lock.
Instead, their formalization adds an additional conversion rule for $\lambda_\text{IS4}$ that we omit
\begin{equation*}
  \inferrule
      [Shift-$\operatorname{unbox}$]
      {\Delta \vdash t : \Box A \\ e : \Xi \\ \Delta, \Xi \lhd \Gamma}
      {\operatorname{unbox} \; t \; (e \circ m) \sim \operatorname{unbox} \; (\textit{wk} \; (\textit{to}_\subseteq \; e) \; t) \; m}
      \mathrlap{\; \lock \notin \Xi}
\end{equation*}
and requires substitution with the identity substitution
to only preserve terms up to conversion,
and likewise for the right identity of substitution composition.

The $(\lhd_{\lambda_\text{IS4}})$ definition used in this development,
see \autoref{fig:is4-m},
is therefore both an opportunity to try an alternative approach,
and, in at least one aspect, simpler,
due to $\textit{rewindPresId}$ only having to be shown once,
instead of being duplicated for both $\textit{subst}$ and substitution composition.
It can either be explicitly reflexive (the $\operatorname{refl}$ constructor),
or any context extension that starts with a \lock{} (the $\operatorname{ext}$ constructor).
With $\operatorname{ext}$ alone it would not be reflexive which, recall,
is a defining factor of IS4,
thereby the addition of $\operatorname{refl}$.

\begin{figure}
  \centering
  \begin{equation*}
    \inferrule{}{\operatorname{refl} : \Gamma \lhd_{\lambda_\text{IS4}} \Gamma} \qquad
    \inferrule{e : \operatorname{Ext} \; (\Delta , \lock) \; \Gamma}{\operatorname{ext} e : \Delta \lhd_{\lambda_\text{IS4}} \Gamma}
  \end{equation*}
  \begin{equation*}
    \inferrule{}{\operatorname{nil} : \operatorname{Ext} \; \Gamma \; \Gamma} \qquad
    \inferrule{e : \operatorname{Ext} \; \Gamma \; \Delta}{\operatorname{snoc} \; e : \operatorname{Ext} \; \Gamma \; (\Delta , A)} \qquad
    \inferrule{e : \operatorname{Ext} \; \Gamma \; \Delta}{\operatorname{snoc}_\lock \; e : \operatorname{Ext} \; \Gamma \; (\Delta , \lock)}
  \end{equation*}
  \caption{Modal accessibility relation for $\lambda_\text{IS4}$.
    The datatype $\operatorname{Ext} \; \Gamma \; \Delta$ is a constructive proof
    of the existence of a context extension from $\Gamma$ to $\Delta$.
    \label{fig:is4-m}}
\end{figure}

The implementations of $\textit{rewind}_\subseteq$ and \textit{rewind}
are similar to their $\lambda_\text{IK}$ counterparts,
with the addition of a $\operatorname{ext} \; (\operatorname{snoc}_\lock \; \_)$ case
that needs to be handled, i.e.\@ for \textit{rewind}:
\begin{multline*}
  \textit{rewind} \; (\operatorname{ext} \; (\operatorname{snoc}_\lock \; m)) \; (\operatorname{lock} \; \sigma \; m_2) \\
  = \textit{trans}_\lhd \; m' \; m_2 , \sigma' \quad \text{where } m' , \sigma' = \textit{rewind} \; (\operatorname{ext} \; m) \; \sigma
\end{multline*}
where $\textit{trans}_\lhd$ is $(\lhd_{\lambda_\text{IS4}})$ composition.
Here, compared to the base case $\operatorname{ext} \; \operatorname{nil}$,
which is the same as for $\lambda_\text{IK}$ in \autoref{eq:ik-rewind}, which see,
rewinding needs to recurse on $\sigma$ from the $\operatorname{lock}$ constructor,
as the modal accessibility relation spans multiple \lock:s.
This gives two modal accessibility relations, $m'$ and $m_2$,
that need to be combined,
and complicates subsequent proofs of the parameters
$\textit{rewindPres-}\circ$ and \textit{rewindWk} quite a bit,
which need a lemma:
\begin{lemma}[The \textit{rewind} operation distributes over $(\lhd_{\lambda_\text{IS4}})$ composition]\label{thm:rewindPresTrans}
  If $m_1 : \Gamma \lhd \Gamma'$, $m_2 : \Gamma' \lhd \Gamma''$, $\sigma : \operatorname{Rpl} \; \Gamma'' \; \Delta$ and
  \begin{equation*}
    \begin{array}{l@{\,}l@{}l}
      m_2', &\sigma'  &\coloneqq \textit{rewind} \; m_2 \; \sigma \\
      m_1', &\sigma'' &\coloneqq \textit{rewind} \; m_1 \; \sigma'
    \end{array}
  \end{equation*}
  then
  $$ \textit{rewind} \; (\textit{trans}_\lhd \; m_1 \; m_2) \; \sigma = \textit{trans}_\lhd \; m_1' \; m_2' , \sigma'' $$
\end{lemma}

For instance, in the $\operatorname{ext} \; (\operatorname{snoc}_\lock \; \_)$ case of $\textit{rewindPres-}\circ$
(recall its definition in \autoref{eq:rewindPres-circ}):
$$ \textit{rewindPres-}\circ \; (\operatorname{ext} \; (\operatorname{snoc}_\lock \; m)) \; (\operatorname{lock} \; \sigma_1 \; m_2) \; \sigma_2 = \, ? $$
it needs to be shown that
\begin{align*}
  &\textit{trans}_\lhd \; (\pi_1 \; X) \; (\pi_1 \; (\textit{rewind} \; m_2 \; \sigma_2)) , \pi_2 \; X \\
  &\quad \stackrel?= \pi_1 \; (\textit{rewind} \; (\textit{trans}_\lhd \; (\pi_1 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1)) \; m_2) \; \sigma_2) \\
  &\qquad , \pi_2 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1) \circ \pi_2 \; (\textit{rewind} \; (\textit{trans}_\lhd \; (\pi_1 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1)) \; m_2) \; \sigma_2)
\end{align*}
where $X \coloneqq \textit{rewind} \; (\operatorname{ext} m) \; (\sigma_1 \circ \pi_2 \; (\textit{rewind} \; m_2 \; \sigma_2))$.
Applying the induction hypothesis on $X$ yields the new left-hand side
\begin{multline*}
  \textit{trans}_\lhd \; (\pi_1 \; (\textit{rewind} \; (\pi_1 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1)) \; (\pi_2 \; (\textit{rewind} \; m_2 \; \sigma_2)))) \; (\pi_1 \; (\textit{rewind} \; m_2 \; \sigma_2)) \\
  , \pi_2 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1) \circ \pi_2 \; (\textit{rewind} \; (\pi_1 \; (\textit{rewind} \; (\operatorname{ext} m) \; \sigma_1)) \; (\pi_2 \; (\textit{rewind} \; m_2 \; \sigma_2)))
\end{multline*}
Here, applying \autoref{thm:rewindPresTrans} with
$m_1 \coloneqq \pi_1 \; (\textit{rewind} \; (\operatorname{ext} \; m) \; \sigma_1)$,
$m_2 \coloneqq m_2$ and $\sigma \coloneqq \sigma_2$,
in order to move $\textit{trans}_\lhd$ into the \textit{rewind} call
and merge the two \textit{rewind}:s right of $(\circ)$,
gives the right-hand side.

Note that all $\lambda_\text{IS4}$ parameters have been proven in Agda\footnote{
See the \texttt{add-is4} branch in the Git repository.},
except for $\textit{rewindPresId}$ which thus far only has a proof on paper,
due to insufficient time.

\chapter{Conclusion}\label{sec:conclusion}

We have given a parametric Fitch-style modal lambda calculus
and shown how to instantiate the calculi $\lambda_\text{IK}$ and $\lambda_\text{IS4}$.
This was done by making the relation between
the contexts involved in the $\operatorname{unbox}$ operation a parameter,
and proceeding to attempt to prove the usual syntactic lemmas
needed to prove correctness of NbE for lambda calculi,
adding additional calculus parameters when stuck.
Ultimately, the objective of formulating a parametric calculus
can be considered to have been met.

An avenue that was initially explored, was requiring $(\lhd)$ to be a context extension,
as it is in both instantiations given in \autoref{sec:instantiations},
and thereby reduce the amount of work needed when instantiating.
Instead more of the syntactic lemmas would able to be proved
directly in the parametric calculus.
For example, it could be done in such a way that the
$\lhd_\lock$, $\textit{rewind-$\lhd_\lock$}$ and $\textit{rewind$_\subseteq$-$\lhd_\lock$}$
parameters become implicit.
This was abandoned, however,
as the convenience did not outweigh the perceived loss of generality.

The parallel between lambda abstractions and boxes,
where similar to how lambdas are applied by supplying an argument value,
boxes can be seen as instead being applied with a modal accessibility relation,
helped when doing the correctness proofs.
Frequently,
this symmetry meant cases concerning $\operatorname{box}$ and $\operatorname{unbox}$
could be somewhat inferred from looking at the equivalent STLC proofs.
Therefore the main difficulties were
proving the substitution laws while simultaneously formulating the parameters,
and choosing a representation of $(\simeq_\text{ctx})$ such that it could be rewound.

The Kripke-style calculus and its normalization by evaluation algorithm by \textcite{hu23},
are undoubtedly similar to the topic of this thesis.
Indeed, the differences between Fitch- and Kripke-style calculi are purely syntactical.
Still, the previous lack of generality of Fitch-style calculi has been quoted \cite{hu18}
as an apparent disadvantage of Fitch-style compared to Kripke-style;
the results in this thesis show that this is not altogether the case.
It is worth mentioning that the Fitch-style is closer to the
categorical semantics given by \textcite{clouston18}.
One has to concede, however, that the Kripke-style formulation is simpler:
The modal accessibility relation is represented as a single integral modal offset,
instead of a proof witness that is carried around of how the past and future contexts are related.

This raises the question of whether the Fitch-style accessibility relation being more general
can be meaningful in some way.
One possible setback of the way things have been done in this thesis,
is that the calculus parameter $\lhd_\lock$ imposes too strict a requirement
on the accessibility relation $(\lhd)$.
For example, a version of $\lambda_\text{IS4}$
where $\Delta \lhd \Gamma$ if removing all \lock:s that occur in $\Gamma$ gives $\Delta$ -
effectively used in \cite{gratzer19} -
is not an instance of the parametric calculus,
instead one would have to also allow e.g.\@ the removal of any number of locks.
That said, the current inclusion of $\lhd_\lock$ does arise naturally
from the need for identity substitutions.

The formalization in \autoref{sec:calculus} made use of the parametric construct $\operatorname{Rpl}$,
in order to cut down on repetition.
\textcite{allais17} demonstrated how the concept can be taken further.
Their result is similar in that renamings, substitutions and semantic environments
may be represented uniformly,
however they go beyond that by implementing a generic term traversal
that may be instantiated to obtain
renaming and substituting of terms and normalization by evaluation, i.a.
Specially useful is how this allows for succinctly proving fusion lemmas,
e.g.\@ that substitution followed by renaming can be subsumed by a single substitution.
Compared to $\operatorname{Rpl}$,
their definition of generalized substitutions uses a function space instead of a datatype,
i.e.\@ substitutions are instances of $\Gamma \ni A \to \Delta \vdash A$,
however this poses problems once modalities are introduced.
With a datatype, interactions with context locks are limited
by what the $\operatorname{lock}$ constructor allows.
With functions we are always able to give a proof of
$\Gamma, \lock \ni A \to \Delta \vdash A$ for any $\Delta$,
as $\Gamma, \lock \ni A$ is uninhabited
since no variables exist to the right of the lock.
This is problematic when using renamings as context morphisms,
since lock weakening is not in general allowed in modal lambda calculi.

A potential for future work is to investigate whether to replace OPE:s with renamings,
i.e. substitutions where the replacement terms are variables.
Not only would this remove
some $\textit{rewind}_\subseteq$/$\textit{rewind}$ repetition in the parameters,
but it would also be a step toward being able to add the \emph{R axiom}
($A \to \Box A$).
\textcite{valliappan-r} showed that the condition
$$ R_m \subseteq R_i $$
on $R_i$ and $R_m$, the intuitionistic and modal accessibility relation, respectively,
is sufficient for ensuring axiom R is satisfied in the model
(with the IR \textsc{Var} rule and corresponding OPE definition).
Unlike with OPE:s as given here,
the condition holds when picking renamings for the intuitionistic accessibility relation,
since renamings encapsulate lock weakenings through the $\operatorname{lock}$ constructor.

Finally,
another thing that was planned in case extra time presented itself by the end of the project,
was implementing supplementary language extensions,
such as Booleans, and/or pattern matching.
Any extension that does not interact with the modal fragment should not pose difficulty,
and it would have been nice to exercise this.
Unfortunately, there was not enough time for this.

\cleardoublepage
\printbibliography[heading=bibintoc]

\end{document}
